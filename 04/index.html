<html>
  <head>
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
    <meta content="utf-8" http-equiv="encoding">
    <title>Default WebGL!</title>
    <style>
      html, body { 
        background-color:#000;
        margin: 0;
        padding: 0;
        height: 100%;
        overflow: hidden !important;  
      }

      body {
        background: url('https://cs460.org/assignments/04/bg.jpg');
        background-size: cover;
      }

      #c {
        width: 100%;
        height: 100%;
      }
      audio { display: none; }
    </style>
  </head>
  <script type="text/javascript" src="https://cs460.org/js/glmatrix.js"></script>
  
  <script id="vertexshader" type="glsl">
    attribute vec3 a_position;

    uniform mat4 u_transform;
    uniform float u_pointsize;

    void main(void) {
      vec4 final_position = u_transform * vec4( a_position, 1. );
      gl_Position = final_position;
      gl_PointSize = u_pointsize;
    
    }
  </script>
  
  <script id="fragmentshader" type="glsl">
    precision mediump float;

    uniform vec4 u_color;

    void main(void) {

      gl_FragColor = u_color;

    }
  </script>
  
  <script>

  var c, gl;
    var v_shader, f_shader, shaderprogram;
    var vertices, indices, v_buffer, i_buffer;
  var all_fish;
  // keyboard state for controlling the big fish
  var keyState = { w: false, s: false };
  // simple Web Audio setup for bubble sounds on W/S
  var audioCtx = null;
  var keyDownOnce = { w: false, s: false };
  function initAudio() {
    if (!audioCtx) {
      const AC = window.AudioContext || window.webkitAudioContext;
      if (AC) audioCtx = new AC();
    }
  }
  function playBubble(freq) {
    if (!audioCtx) return;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = 'sine';
    o.frequency.setValueAtTime(freq || 700, audioCtx.currentTime);
    o.connect(g); g.connect(audioCtx.destination);
    const now = audioCtx.currentTime;
    g.gain.setValueAtTime(0.0, now);
    g.gain.linearRampToValueAtTime(0.2, now + 0.02);
    g.gain.exponentialRampToValueAtTime(0.0001, now + 0.25);
    o.start(now);
    o.stop(now + 0.3);
  }

    window.onload = function() {

      //************************************************************//
      //
      // INITIALIZE WEBGL
      //
      c = document.getElementById( 'c' ); // setup canvas
      c.width = window.innerWidth;
      c.height = window.innerHeight;

      gl = c.getContext( 'webgl' ); // setup GL context
      gl.viewport(0, 0, c.width, c.height );


      //************************************************************//
      //
      // SHADERS
      //
      v_shader = gl.createShader( gl.VERTEX_SHADER );
      f_shader = gl.createShader( gl.FRAGMENT_SHADER );
      
      // compile vertex shader
      gl.shaderSource( v_shader, document.getElementById( 'vertexshader' ).innerText );
      gl.compileShader( v_shader );

      if (!gl.getShaderParameter( v_shader, gl.COMPILE_STATUS)) {
        console.log(gl.getShaderInfoLog( v_shader ));
      }

      // compile fragment shader
      gl.shaderSource( f_shader, document.getElementById( 'fragmentshader' ).innerText );
      gl.compileShader( f_shader );

      if (!gl.getShaderParameter( f_shader, gl.COMPILE_STATUS)) {
        console.log(gl.getShaderInfoLog( f_shader ));
      }

      // attach and link the shaders
      shaderprogram = gl.createProgram();
      gl.attachShader( shaderprogram, v_shader );
      gl.attachShader( shaderprogram, f_shader );

      gl.linkProgram( shaderprogram );

      gl.useProgram( shaderprogram );


      // create many fish
        all_fish = [];
      // one large red fish in center, flipped (direction -1)
        all_fish.push( createFish( new Float32Array([0.,0.,0.]), new Float32Array([1.,0.,0.,1.]), 1., -1.) );
      // a bunch of random fish (reduced to 20)
      for (var i = 0; i < 20; i++) {
        var random_color  = new Float32Array([ Math.random(), Math.random(), Math.random(), 1. ]);
        var random_offset = new Float32Array([ Math.random()-Math.random(), Math.random()-Math.random(), 0. ]);
        var random_scale  = Math.random()*0.3;
        all_fish.push( createFish( random_offset, random_color, random_scale, 1.) );
      }



      // keyboard listeners (W/S control the big fish vertically; B toggles background song)
      window.addEventListener('keydown', function(e){
        if (e.key === 'w' || e.key === 'W') {
          keyState.w = true; initAudio(); if (!keyDownOnce.w) { playBubble(760); keyDownOnce.w = true; }
        }
        if (e.key === 's' || e.key === 'S') {
          keyState.s = true; initAudio(); if (!keyDownOnce.s) { playBubble(520); keyDownOnce.s = true; }
        }
        if (e.key === 'b' || e.key === 'B') {
          var el = document.getElementById('bgSong');
          var hint = document.getElementById('audioHint');
          if (el) {
            if (el.paused) {
              var p = el.play();
              if (p && p.then) {
                p.then(function(){ if (hint) hint.style.display = 'none'; });
                if (p.catch) p.catch(function(){ if (hint) hint.style.display = 'block'; });
              }
            } else {
              el.pause();
              if (hint) hint.style.display = 'block';
            }
          }
        }
      });
      window.addEventListener('keyup', function(e){
        if (e.key === 'w' || e.key === 'W') { keyState.w = false; keyDownOnce.w = false; }
        if (e.key === 's' || e.key === 'S') { keyState.s = false; keyDownOnce.s = false; }
      });

      animate();

    };


  function createFish(offset, color, scale=1., direction=1.) {


      //************************************************************//
      //
      // CREATE GEOMETRY
      //
      // fish vertices (nose to tail), can be scaled later if needed
      var vertices = new Float32Array([
                                      0.5,  0.0, 0.0,  // 0: nose
                                      0.2,  0.25,0.0,  // 1: upper body
                                     -0.2,  0.15,0.0,  // 2: upper tail base
                                     -0.4,  0.3, 0.0,  // 3: upper tail tip
                                     -0.4, -0.3, 0.0,  // 4: lower tail tip
                                     -0.2, -0.15,0.0,  // 5: lower tail base
                                      0.2, -0.25,0.0   // 6: lower body
                                    ]);

      // fish made from 5 triangles (15 indices)
      var indices = new Uint8Array([
                                    0, 1, 6,  // main body
                                    1, 2, 6,  // upper mid-body
                                    2, 5, 6,  // rear body
                                    2, 3, 5,  // tail top
                                    3, 4, 5   // tail fin
                                  ]);

      // eye position; flip vertically if direction is -1 so eye remains on top side
      var eye_vertex = new Float32Array([0.2, 0.2, 0.0]);
      if (direction === -1) {
        eye_vertex = new Float32Array([0.2, -0.2, 0.0]);
      }

      var eye_v_buffer = gl.createBuffer();
      gl.bindBuffer( gl.ARRAY_BUFFER, eye_v_buffer );
      gl.bufferData( gl.ARRAY_BUFFER, eye_vertex, gl.STATIC_DRAW );
      gl.bindBuffer( gl.ARRAY_BUFFER, null );

      var v_buffer = gl.createBuffer(); // create
      gl.bindBuffer( gl.ARRAY_BUFFER, v_buffer ); // bind
      gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW ); // put data in
      gl.bindBuffer( gl.ARRAY_BUFFER, null ); // unbind

      var i_buffer = gl.createBuffer(); // create
      gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, i_buffer ); // bind
      gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW ); // put data in
      gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, null ); // unbind


  // store eye buffer, scale and direction for future use
  return [v_buffer, i_buffer, eye_v_buffer, color, offset, scale, direction];

    };

    var step_x = .01;
    var step_y = .01;

    function animate() {

      requestAnimationFrame(animate);

      gl.clearColor( 0., 0., 0., 0.)
      gl.clear( gl.COLOR_BUFFER_BIT );

  // enable transparency blending (Part 9)
  gl.enable(gl.BLEND);
  gl.blendEquation(gl.FUNC_ADD);
  gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
  gl.disable(gl.DEPTH_TEST);



  for( var r = 0; r < all_fish.length; r++ ) {

        // current_buffers is a list of [v_buffer, i_buffer]-pairs
  var current_buffers = all_fish[r];
  var current_v_buffer = current_buffers[0];
  var current_i_buffer = current_buffers[1];
  var current_eye_v_buffer = current_buffers[2];
  var current_color = current_buffers[3];
  var current_offset = current_buffers[4];
  var current_scale = current_buffers[5];
  var current_direction = current_buffers[6];

        // update offsets
        // Movement: respect direction (d=1 -> right, d=-1 -> left) and gentle vertical wiggle
        var horizSpeed = 0.001;
        current_offset[0] += horizSpeed * (current_direction === -1 ? -1 : 1);
        // vertical motion: user control for the big fish (r==0), random wiggle for others
        if (r === 0) {
          if (keyState.w) current_offset[1] += 0.01;
          if (keyState.s) current_offset[1] -= 0.01;
        } else {
          current_offset[1] += 0.005*Math.random();
          current_offset[1] -= 0.005*Math.random();
        }

        // clamp vertical position to viewport
        if (current_offset[1] > 1.) current_offset[1] = 1.;
        if (current_offset[1] < -1.) current_offset[1] = -1.;

        // Wrap around depending on direction
        if ( current_direction === 1 && current_offset[0] >= 1. ) {
          current_offset[0] = -1.;
        }
        if ( current_direction === -1 && current_offset[0] <= -1. ) {
          current_offset[0] = 1.;
        }

        // persist updated direction
  current_buffers[6] = current_direction;
        



        //************************************************************//
        //
        // CONNECT SHADER WITH GEOMETRY
        //
        
        gl.bindBuffer( gl.ARRAY_BUFFER, current_v_buffer );

        gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, current_i_buffer );

        // find the attribute in the shader source
        var a_position = gl.getAttribLocation( shaderprogram, 'a_position' );

        gl.vertexAttribPointer( a_position, 3, gl.FLOAT, false, 0, 0 );

        gl.enableVertexAttribArray ( a_position );

        // build transform matrix (column-major): add random small rotation around Z and translation
        var theta = Math.random()*10 * Math.PI/180; // 0..10 degrees in radians
        var cth = Math.cos(theta);
        var sth = Math.sin(theta);
        var s = current_scale;
        var d = current_direction;
        var transform = [
          d*s*cth,  sth,     0, 0,
          -sth,   d*s*cth,  0, 0,
            0,       0,   d*s*1, 0,
          current_offset[0], current_offset[1], current_offset[2], 1
        ];

        var u_transform = gl.getUniformLocation( shaderprogram, 'u_transform' );
        gl.uniformMatrix4fv( u_transform, false, new Float32Array(transform) );

        var u_color = gl.getUniformLocation( shaderprogram, 'u_color' );
        // Pulsating color per fish based on its base random color; keep big fish red
        var t = performance.now() * 0.001;
        var a = 0.6 + 0.4 * Math.sin(t * 2.0); // pulsating alpha

        var dynamic_color;
        if (r === 0) {
          // Big fish stays red
          dynamic_color = new Float32Array([1., 0., 0., 0.7]);
        } else {
          var base = current_color; // random color from creation
          var p0 = r * 0.73;
          var p1 = r * 1.11 + 1.23;
          var p2 = r * 0.89 + 2.34;
          var rch = Math.min(Math.max(base[0] * (0.7 + 0.3*Math.sin(t + p0)), 0.), 1.);
          var gch = Math.min(Math.max(base[1] * (0.7 + 0.3*Math.sin(t + p1)), 0.), 1.);
          var bch = Math.min(Math.max(base[2] * (0.7 + 0.3*Math.sin(t + p2)), 0.), 1.);
          dynamic_color = new Float32Array([rch, gch, bch, a]);
        }

        gl.uniform4fv( u_color, dynamic_color );

        //************************************************************//
        //
        // DRAW!
        //


        // gl.drawArrays( gl.TRIANGLES, 0, 6 );
        gl.drawElements( gl.TRIANGLES, 15, gl.UNSIGNED_BYTE, 0);

        // draw the eye as a point
        gl.bindBuffer( gl.ARRAY_BUFFER, current_eye_v_buffer );
        gl.vertexAttribPointer( a_position, 3, gl.FLOAT, false, 0, 0 );
        gl.enableVertexAttribArray ( a_position );

  // set eye size proportional to scale and color to black with slight transparency
        var u_pointsize = gl.getUniformLocation( shaderprogram, 'u_pointsize' );
  gl.uniform1f( u_pointsize, 20.0 * current_scale );

  gl.uniform4fv( u_color, new Float32Array([0.,0.,0.,0.5]) );
        gl.drawArrays( gl.POINTS, 0, 1 );

      }


    };

  </script>
  <body>
  <!-- background song; place underwater.mp3 in this folder; press B or click to play/pause -->
  <audio id="bgSong" src="underwater-ambience-6201.mp3" loop preload="auto" playsinline></audio>
    <div id="audioHint" style="position:absolute;left:10px;top:10px;color:#fff;font-family:system-ui,sans-serif;font-size:13px;background:rgba(0,0,0,.4);padding:6px 10px;border-radius:6px;">
      Press B to enable/stop sound<br>
      Press W/S to move the big fish up/down
    </div>
    <canvas id="c"></canvas>
    <script>
      // set a comfortable default volume for the background song
      (function(){
        var el = document.getElementById('bgSong');
        if (el) el.volume = 0.2;
      })();
    </script>
  </body>
</html>
